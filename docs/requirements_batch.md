# Oura Ring データ収集バッチ 要件定義

## 1. 背景・目的
- Oura Ring の Web API を活用してユーザのウェルネス指標（睡眠、活動量、レディネスなど）を取得し、将来的に UI で可視化するプラットフォーム「healthHub」を構築する。
- 本フェーズでは、API から定期的にデータを取得し、安全に蓄積するバッチ処理を実装するための要件を定義する。

## 2. スコープ
- 対象: バッチ処理（API 呼び出し・データ取得・保存・監視）。
- 非対象: UI 表示機能、ユーザ管理機能、データ分析・通知処理。
- 対象データ: Oura Ring API が提供する日次サマリーデータ（Sleep, Readiness, Activity）およびメタデータ。必要に応じて拡張を想定。

## 3. 利害関係者
| 役割 | 責務 |
| --- | --- |
| プロダクトオーナー | ビジネス要件・優先順位の決定 |
| 開発チーム | バッチ処理の設計・実装・テスト |
| 運用チーム | システム運用・監視・トークン管理 |
| 利用者（最終的な UI ユーザ） | 将来的にデータを参照するが、本フェーズでは間接的 |

## 4. 用語
- **Oura API**: Oura Ring が公開する REST API。OAuth2 Personal Access Token を使用して認証。
- **バッチ処理**: スケジュールに基づき自動実行するデータ取得プログラム。
- **ストレージ**: 取得したデータを保存する永続化層。本フェーズでは初期コストを抑えるため、サーバレスでセットアップが容易な SQLite を標準とする。

## 5. 前提条件・制約
- 認証には Oura API の Personal Access Token (PAT) を使用し、システム設定として安全に格納する（例: Secrets Manager、.env ファイル等）。
- PAT はユーザ単位。複数ユーザを扱う場合は、ユーザ毎にトークンを保持できる仕組みを追加する。
- バッチは当初 1 ユーザ分のデータ取得から開始し、将来的な多ユーザ化を想定した設計（ユーザ ID をキーとした拡張可能なデータモデル）。
- 実行環境は Linux ベースのサーバを想定。CI/CD・コンテナ化は任意。

## 6. 機能要件
### 6.1 スケジューリング
- バッチは日次で実行し、前日分のデータを取得する。
- 追加要件として、任意期間の再取得（リカバリ）を行える手動トリガーを用意する。
- スケジュール管理は cron、あるいはクラウドスケジューラ（例: AWS EventBridge）を想定。第一段階では OS の cron で実現してよい。

### 6.2 データ取得
- Oura API の `https://api.ouraring.com/v2/usercollection/` 系エンドポイントを使用し、以下を取得する。
  - `/sleep` 日次睡眠サマリー
  - `/readiness` 日次レディネススコア
  - `/activity` 日次活動サマリー
- API リクエストには ISO 8601 の日付範囲 (start_date, end_date) を指定する。
- レスポンスがページングされる場合は全ページ取得する。
- API 呼び出しの失敗時はリトライ（指数バックオフ、最大 3 回）を行う。

### 6.3 データ変換
- API レスポンス JSON をアプリ内の共通フォーマットにマッピングする。
- タイムゾーンは UTC を基準とし、必要に応じてローカルタイムに変換できるよう生データも保持する。
- 数値項目は小数点精度・単位を API ドキュメントに準拠して保持する。

### 6.4 データ保存
- 保存対象:
  - メタ情報: 取得日、対象期間、ユーザ ID、ソース API、取得時刻。
  - 指標データ: スコア、時間（睡眠時間、活動時間など）、各種タグ。
- 正常終了時は SQLite 上の以下のテーブルを更新する（テーブル設計は別途詳細設計で定義）。将来的な負荷増大時は PostgreSQL などマネージド RDB への移行を想定し、SQL 方言への依存を最小化する。
  - `oura_sleep_summaries`
  - `oura_readiness_summaries`
  - `oura_activity_summaries`
- 重複データを防ぐため、(ユーザ ID, 日付) で upsert（INSERT ... ON CONFLICT）を行う。
- データの永続化前にスキーマ検証（必須フィールドのチェック）を行う。

### 6.5 例外・エラー処理
- API からの 4xx, 5xx 応答時は、HTTP ステータス・レスポンスボディを記録し通知する。
- リトライ失敗時は失敗理由をログ出力し、アラート（メール or Slack Webhook）を発報する。
- データ整形時にバリデーションエラーが発生した場合は該当レコードをスキップし、エラーの詳細をログに残す。

## 7. 非機能要件
### 7.1 性能
- 1 ユーザあたりの日次データ取得・保存が 1 分以内に完了すること。
- 将来的な多ユーザ化を考慮し、バッチ実行時間はユーザ数に線形で増加しても 1 時間以内で完了するよう設計する。

### 7.2 可用性・信頼性
- スケジューラの実行結果（成功・失敗）を記録する。
- バッチ異常時には 1 時間以内に通知が行われる運用体制を整備する。
- リトライや再取得の仕組みにより、一時的な API 障害でもデータ欠損を最小化する。

### 7.3 セキュリティ
- PAT は環境変数やシークレットマネージャーで暗号化して保管する。
- 通信は HTTPS を使用するため追加の暗号化は不要だが、証明書検証を無効化しない。
- ログにトークンや個人が特定可能なデータを残さない。

### 7.4 ロギング・監視
- 取得対象日付、API 呼び出し URL、処理件数、成功/失敗ステータスを INFO ログで記録する。
- エラー詳細は ERROR レベルで記録し、通知チャネルに送信する。
- ログフォーマットは JSON を推奨し、将来的な解析・可視化（例: CloudWatch Logs, ELK）に対応する。

### 7.5 テスト
- 単体テスト: API クライアント、データマッピング、DB 永続化ロジックをモックを用いてテストする。
- 結合テスト: ステージング環境で実際の Oura API またはサンドボックスを用いて日次実行フローを確認する。
- 運用テスト: スケジューラでの定期実行と通知の動作確認。

## 8. 運用・保守要件
- スケジューラ設定や環境変数の変更手順を運用 Runbook にまとめる。
- PAT の期限や失効に備え、更新手順と通知フローを整備する。
- データの再取得手順（対象期間の指定、実行方法）を文書化する。
- DB バックアップは SQLite ファイルを日次で取得し、保管期間は 90 日とする。

## 9. 将来拡張
- 多ユーザ対応のためのトークン管理・ユーザ設定テーブルの追加。
- 週次・月次集計バッチや、UI 向け API の公開。
- 異常検知やヘルスレコメンドなどの派生機能。

## 10. 承認フロー
- 本要件定義はプロダクトオーナーおよび開発リードがレビューし承認する。
- 承認後、詳細設計フェーズに進む。
